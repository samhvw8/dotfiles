# =============================================================================
# ZSH Configuration - Optimized & Readable
# =============================================================================

# if [[ "$TERM_PROGRAM" == "vscode" ]]; then
#     if [ -f "$HOME/.local/bin/mise" ]; then 
#         eval "$($HOME/.local/bin/mise activate zsh)"
#         eval "$($HOME/.local/bin/mise hook-env)"
#     fi
# else
if [ -f "$HOME/.local/bin/mise" ]; then 
    eval "$($HOME/.local/bin/mise activate zsh)"
    eval "$($HOME/.local/bin/mise hook-env)"
fi
# fi


# Basic ZSH Options
setopt SHARE_HISTORY INC_APPEND_HISTORY HIST_NO_STORE
setopt appendhistory beep nomatch promptsubst

# XDG Base Directories
export XDG_CONFIG_HOME="${HOME}/.config"
export XDG_CACHE_HOME="${HOME}/.cache"
export XDG_DATA_HOME="${HOME}/.local/share"
export XDG_STATE_HOME="${HOME}/.local/state"
export XDG_RUNTIME_DIR="${HOME}/.local/run"

# ZSH-specific directories
export ZSH_DATA_DIR="${XDG_DATA_HOME}/zsh"
export ZSH_CACHE_DIR="${XDG_CACHE_HOME}/zsh"
export ZSH_COMPDUMP="${ZSH_CACHE_DIR}/zcompdump"

# Create necessary directories
for dir in "$XDG_CONFIG_HOME" "$XDG_CACHE_HOME" "$XDG_DATA_HOME" "$XDG_STATE_HOME" "$XDG_RUNTIME_DIR" \
           "$ZSH_DATA_DIR" "$ZSH_CACHE_DIR" "$ZSH_CACHE_DIR/completions"; do
    [[ ! -d "$dir" ]] && mkdir -p "$dir"
done

# =============================================================================
# ZI Plugin Manager
# =============================================================================

# Install ZI if not present
if [[ ! -f $HOME/.zi/bin/zi.zsh ]]; then
    print -P "%F{33}Installing ZI...%f"
    command mkdir -p "$HOME/.zi" && command chmod go-rwX "$HOME/.zi"
    command git clone -q --depth=1 https://github.com/z-shell/zi "$HOME/.zi/bin" || return 1
fi

# Source ZI
source "$HOME/.zi/bin/zi.zsh"
autoload -Uz _zi
(( ${+_comps} )) && _comps[zi]=_zi

# Load annexes
zi light-mode for z-shell/z-a-meta-plugins @annexes
zicompinit

# =============================================================================
# Helper Functions
# =============================================================================

command_exists() { 
    command -v "$1" >/dev/null 2>&1
}

add_to_path() { 
    [[ -d "$1" ]] && export PATH="$1:$PATH"
}

fbd() {
    git for-each-ref --count=30 --sort=-committerdate refs/heads/ --format="%(refname:short)" | \
    fzf --multi | xargs -r git branch -D
}

# =============================================================================
# Prompt - Starship (installed via mise)
# =============================================================================

command_exists starship && eval "$(starship init zsh)"

# =============================================================================
# Tool Completions
# =============================================================================

# Generate completions for common tools
for tool in mise kubectl helm; do
    if command_exists $tool; then
        comp_file="$ZSH_CACHE_DIR/completions/_$tool"
        [[ ! -f "$comp_file" ]] && $tool completion zsh > "$comp_file" 2>/dev/null
        if [[ -f "$comp_file" ]]; then
            zi ice as"completion"
            zi snippet "$comp_file"
        fi
    fi
done

# =============================================================================
# Oh-My-Zsh Integration
# =============================================================================

# Load essential OMZ library
zi lucid for OMZL::history.zsh

# Load OMZ libraries and plugins with delay
zi wait lucid for \
    OMZL::clipboard.zsh \
    OMZL::compfix.zsh \
    OMZL::completion.zsh \
    OMZL::correction.zsh \
    OMZL::directories.zsh \
    OMZL::git.zsh \
    OMZL::grep.zsh \
    OMZL::spectrum.zsh \
    OMZP::git \
    OMZP::urltools \
    OMZP::extract \
    OMZP::encode64

# =============================================================================
# Aliases
# =============================================================================

# Directory navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

# File operations
alias ls='ls --color=auto'
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Kubernetes shortcuts
if command_exists kubectl; then
    alias k=kubectl
    alias kaf='kubectl apply -f'
fi

# Editor shortcuts
if command_exists nvim; then
    alias vim=nvim
    alias vimo=/usr/bin/vim
    alias nvimo="nvim -u NORC --noplugin"
    export EDITOR=nvim
fi

# =============================================================================
# Additional Tools
# =============================================================================

# FZF integration
if [[ -f "$HOME/.fzf.zsh" ]]; then
    zi ice wait"0" lucid
    zi snippet "$HOME/.fzf.zsh"
    zi light Aloxaf/fzf-tab
    zi light wfxr/forgit
fi

# Docker completions (full installation only)
if command_exists docker; then
    zi ice as"completion"
    zi snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker
    zi snippet https://github.com/docker/compose/blob/v1/contrib/completion/zsh/_docker-compose
fi

# Zoxide (installed via mise)
command_exists zoxide && eval "$(zoxide init --cmd j zsh)"

# Additional completions
zi ice lucid wait as'completion' blockf
zi snippet https://github.com/rust-lang/cargo/blob/master/src/etc/_cargo

# =============================================================================
# ZSH Enhancements
# =============================================================================

# Syntax highlighting, completions, and autosuggestions
zi wait lucid for \
    atinit"ZI[COMPINIT_OPTS]=-C; zicompinit; zicdreplay" \
        z-shell/fast-syntax-highlighting \
    blockf \
        zsh-users/zsh-completions \
    atload"!_zsh_autosuggest_start" \
        zsh-users/zsh-autosuggestions

# Optional tools
# Note: Now using chezmoi for dotfile management instead of dotbare

zi ice wait lucid
zi light "MichaelAquilina/zsh-you-should-use"

# =============================================================================
# PATH Configuration
# =============================================================================

add_to_path "$HOME/.local/bin"
add_to_path "$HOME/bin"
add_to_path "${KREW_ROOT:-$HOME/.krew}/bin"

# =============================================================================
# OS-specific Configuration
# =============================================================================

if [[ $(uname) == "Darwin" ]]; then
    # macOS specific
    [[ -e "${HOME}/.iterm2_shell_integration.zsh" ]] && source "${HOME}/.iterm2_shell_integration.zsh"
    export HOMEBREW_NO_INSTALL_CLEANUP=1
    add_to_path "/usr/local/sbin"
    add_to_path "/usr/local/opt/icu4c/bin"
    add_to_path "/usr/local/opt/icu4c/sbin"
else
    # Linux specific
    alias open=xdg-open
    [[ -f "$HOME/idea/idea-IC-203.8084.24/bin/idea.sh" ]] && \
        alias idea="$HOME/idea/idea-IC-203.8084.24/bin/idea.sh"
fi

# =============================================================================
# Environment Variables
# =============================================================================

export DIRENV_LOG_FORMAT=
export LC_ALL="en_US.UTF-8"
export LANG="en_US.UTF-8"
export LANGUAGE="en_US.UTF-8"
export BAT_THEME="Dracula"

# FZF configuration
export FZF_DEFAULT_OPTS='
--color=dark
--color=fg:-1,bg:-1,hl:#5fff87,fg+:-1,bg+:-1,hl+:#ffaf5f
--color=info:#af87ff,prompt:#5fff87,pointer:#ff87d7,marker:#ff87d7,spinner:#ff87d7
'
export FZF_DEFAULT_COMMAND='fd --type file'

# =============================================================================
# Conda Configuration
# =============================================================================
# Determine Conda base directory (full installation only)
if command_exists conda; then
    export _CONDA_BASE=$(dirname $(dirname $(which conda)))
elif [[ $(uname) == "Darwin" ]]; then
    export _CONDA_BASE=/opt/homebrew/Caskroom/miniconda/base
else
    export _CONDA_BASE=$HOME/miniconda3
fi

# Initialize Conda if available
if [[ -f "$_CONDA_BASE/bin/conda" ]]; then
    __conda_setup="$('$_CONDA_BASE/bin/conda' 'shell.zsh' 'hook' 2>/dev/null)"
    if [[ $? -eq 0 ]]; then
        eval "$__conda_setup"
    elif [[ -f "$_CONDA_BASE/etc/profile.d/conda.sh" ]]; then
        . "$_CONDA_BASE/etc/profile.d/conda.sh"
    else
        export PATH="$_CONDA_BASE/bin:$PATH"
    fi
    unset __conda_setup
fi

# =============================================================================
# Additional Sources
# =============================================================================

[[ -s "$HOME/.config/envman/load.sh" ]] && source "$HOME/.config/envman/load.sh"
[[ -f "$HOME/.kubecm" ]] && source "$HOME/.kubecm"

# =============================================================================
# Key Bindings
# =============================================================================

set -o emacs
autoload -U edit-command-line
zle -N edit-command-line
bindkey '^X^E' edit-command-line  # Ctrl-X-E to edit command in editor

# pnpm
export PNPM_HOME="/Users/samhv/.local/share/pnpm"
case ":$PATH:" in
  *":$PNPM_HOME:"*) ;;
  *) export PATH="$PNPM_HOME:$PATH" ;;
esac
# pnpm end

bindkey "^[[1;5C" forward-word
bindkey "^[[1;5D" backward-word

# =============================================================================
# Case Variant Search (rgv - ripgrep with case variants)
# =============================================================================

# Convert input to word array (splits on _ - . or camelCase boundaries)
_to_words() {
    local input="$1"
    # Replace separators with spaces, then handle camelCase
    echo "$input" | \
        sed -E 's/[-_.]/ /g' | \
        sed -E 's/([a-z])([A-Z])/\1 \2/g' | \
        tr '[:upper:]' '[:lower:]'
}

# Generate all case variants from a variable name
_case_variants() {
    local input="$1"
    local words=($(_to_words "$input"))

    [[ ${#words[@]} -eq 0 ]] && return 1

    local snake="" camel="" pascal="" upper="" kebab="" dot="" lower=""
    local first=true

    for word in "${words[@]}"; do
        local lower_word="${word:l}"
        local upper_word="${word:u}"
        local cap_word="${(C)word}"

        # snake_case
        [[ -n "$snake" ]] && snake+="_"
        snake+="$lower_word"

        # camelCase
        if $first; then
            camel+="$lower_word"
        else
            camel+="$cap_word"
        fi

        # PascalCase
        pascal+="$cap_word"

        # UPPER_CASE
        [[ -n "$upper" ]] && upper+="_"
        upper+="$upper_word"

        # kebab-case
        [[ -n "$kebab" ]] && kebab+="-"
        kebab+="$lower_word"

        # dot.case
        [[ -n "$dot" ]] && dot+="."
        dot+="$lower_word"

        # lowercase (no separator)
        lower+="$lower_word"

        first=false
    done

    # Output unique variants
    printf '%s\n' "$snake" "$camel" "$pascal" "$upper" "$kebab" "$dot" "$lower" | sort -u
}

# ripgrep with case variants
# Usage: rgv <variable_name> [rg_options...]
# Example: rgv price_nego -t py
#          rgv priceNego --type ts -l
rgv() {
    if [[ $# -eq 0 ]]; then
        echo "Usage: rgv <variable_name> [rg_options...]"
        echo "Searches for all case variants: snake_case, camelCase, PascalCase, UPPER_CASE, kebab-case, dot.case"
        echo ""
        echo "Examples:"
        echo "  rgv price_nego           # Search all variants"
        echo "  rgv priceNego -t py      # Search in Python files"
        echo "  rgv PriceNego -l         # List matching files only"
        return 1
    fi

    local pattern="$1"
    shift

    # Generate variants and pipe to ripgrep
    _case_variants "$pattern" | rg -f - "$@"
}

# Show what variants will be searched (for debugging)
rgv-show() {
    if [[ $# -eq 0 ]]; then
        echo "Usage: rgv-show <variable_name>"
        return 1
    fi
    echo "Case variants for '$1':"
    _case_variants "$1" | while read -r v; do
        echo "  - $v"
    done
}
